"""
당신의 학과에는 N개의 필수 과목들이 있다.
과목들은 1번부터 N번까지 번호가 붙어 있다.
한 학기에는 가능한 모든 과목을 한꺼번에 들을 수 있다
각 과목에는 선수 과목의 번호들이 있어서 선수 과목들 중 하나라도 이전 학기까지 완료하지 못한 경우는 해당 과목을 실패한다.
물론 첫 학기에는 이전 학기까지 완료한 과목이 없다.
선수 과목들 모두를 이전 학기까지 완료한 경우는 이번 학기에 해당 과목을 완료하게 된다.
선수 과목이 없는 과목은 첫 학기에 완료된다.
모든 과목을 완료하는 데 몇 학기가 필요한지 계산하라.
아래 그림과 같은 상황을 생각하자.

그림에는 4개의 과목이 있으며 화살표가 나가는 과목이 들어가는 과목의 선수 과목이라는 의미이다
1번째 학기에는 4번 과목만 (선수 과목이 없으므로) 완료가 가능하다.
2번째 학기에는 3번 과목만 완료가 되고, 3번째 학기에는 1번 과목이, 마지막으로 4번째 학기에 2번 과목이 완료된다.
모든 과목을 완료하는 데 몇 학기가 필요한지 계산하라.
모든 과목을 완료하는 것이 불가능할 수도 있음에 주의하라.

[제약사항]
1. 과목의 개수 N은 2 이상 100 이하이다. (2 ≤ N ≤ 100)
2. 과목들의 선수과목 개수의 총 합은 1 이상 120 이하이다.
3. 선수 과목의 개수가 0인 과목이 하나도 없을 수도 있다.

[입력]
가장 첫 줄에는 테스트 케이스의 총 수가 주어진다.
그 다음 줄부터 각 테스트 케이스가 주어지며, 각 테스트 케이스는 N+1줄로 구성된다.
각 테스트 케이스의 첫 번째 줄에는 과목의 수 N이 주어진다.
다음 N개의 줄에 번호 순서대로 각 과목의 선수 과목들의 번호가 주어진다.
X번 과목에 해당하는 한 줄에는 X번 과목의 선수 과목 개수가 주어지고 (개수가 0일 수 있음에 주의하라),
다음에 그 개수 만큼의 과목들 번호가 주어진다.
한 줄에 주어지는 번호에 중복은 없다.

[출력]
출력의 각 줄은 ‘#x’로 시작하고, 공백을 한 칸 둔 다음 모든 과목을 완료하는데 필요한 최소 학기 수를 출력한다.
단, x는 테스트 케이스의 번호이다. 모든 과목을 완료하는 것이 불가능한 경우 -1을 출력한다.

"""


import sys

sys.stdin = open('sample_input_a1.txt')

T = int(input())

# 특정 과목의 학기가 갱신되었을 때, 그 과목을 선수 과목으로 하는 후속 과목들의 학기를 연쇄적으로 갱신
def check_sub(subject, sub, sem):
    # subject를 선수 과목으로 가지는 후속 과목 k 확인
    for k in sub[subject]:
        # 후속 과목의 학기가 선수 과목 학기보다 작거나 같다면 갱신 필요
        if sem[k] <= sem[subject]:
            sem[k] = sem[subject] + 1
            # 학기 수가 총 과목 수(N)를 초과하면 무한 루프로 간주하여 함수 종료, -1 반환
            if sem[k] > len(sem) - 1:
                return -1
            # 갱신된 학기를 바탕으로 다시 후속 과목들 탐색 (재귀)
            check_sub(k, sub, sem)
        else:
            continue

for test_case in range(1, T + 1):
    # 총 과목 수
    N = int(input())
    # 선수 과목 데이터 (0번 인덱스: 해당 과목의 선수 과목 개수, 1번 이후: 선수 과목 번호들)
    subjects = [list(map(int, input().split())) for _ in range(N)]

    # 각 과목당 필요한 최소 학기 저장 (1로 초기화)
    # 과목 번호가 1부터 시작하므로 0번 인덱스는 비워둠
    semester = [1] * (N + 1)
    # 각 과목 번호를 인덱스로 하여 '그 과목 이후에 들을 과목들(후속 과목)'을 담는 리스트
    sub_seq = [[] for _ in range(N + 1)]
    subject_num = 0

    # for i in range(N):
    #     subject_num = i + 1
    #     if subjects[i][0] != 0:
    #         pre_req = subjects[i][1:]
    #         semester[subject_num] = max(max(semester[x] for x in pre_req) + 1, semester[subject_num])
    #
    #         for j in pre_req:
    #             sub_seq[j].append(subject_num)
    #
    #         if check_sub(subject_num, sub_seq, semester) == -1:
    #             result = -1
    #             break

    # 언패킹을 활용해 선수 과목 개수(n)와 리스트(pre_req)를 분리하여 순회
    for n, *pre_req in subjects:
        # 1번 과목부터 차례대로 번호 매김
        subject_num += 1

        # 선수 과목이 존재하는 경우
        if n != 0:
            # 1) 현재 과목의 학기 결정: 선수 과목 중 가장 늦게 끝나는 학기 + 1
            semester[subject_num] = max(max(semester[x] for x in pre_req) + 1, semester[subject_num])

            # 2) # 각 선수 과목들의 '후속 과목 목록'에 현재 과목 번호를 추가
            for i in pre_req:
                sub_seq[i].append(subject_num)

            # 3) 현재 과목의 학기가 변했으므로, 이 과목을 먼저 수강해야하는 후속 과목들의 학기 갱신 (재귀함수 호출)
            # 무한 루프로 간주되어 -1을 반환한다면 반복 종료, 결과 변수에 -1 할당
            if check_sub(subject_num, sub_seq, semester) == -1:
                result = -1
                break
    else:
        # 모든 루프가 정상 종료되면 가장 큰 학기 값을 결과 변수에 할당
        result = max(semester)

    print(f'#{test_case} {result}')









"""
몬스터를 사냥하는 헌터가 있다. 헌터는 상하좌우로 움직이고 몬스터를 사냥한다.

헌터는 몬스터를 처리하고 몬스터를 없애줄 것을 요청한 고객이 몬스터가 처리된 것을 확인하면 작업이 완료된다.



몬스터를 처리하는 순서는 상관이 없다. 고객들에게 확인시켜 주는 순서도 상관이 없다.

몬스터를 처리했다고 해서 바로 그 몬스터를 처리해 달라고 요청한 고객에게 돌아가 확인할 필요도 없다.



헌터는 1시간에 한 칸씩 상하좌우로 움직인다.



몬스터를 처리하기 위해서는 헌터는 몬스터가 있는 위치로 가면 된다.

헌터가 실력이 좋아서 몬스터를 처리하는 데 걸리는 시간은 없다.



고객에게 몬스터를 처리한 것을 확인시켜 주기 위해서 고객이 있는 위치로 가면 된다.

고객이 확인하는 데 걸리는 시간은 없다.



예로, [그림-1]을 보자





                                [그림-1]



헌터는 (1, 1)에 있다.

몬스터 1은 (4, 3), 몬스터 2는 (3, 5), 몬스터 3은 (2, 4)에 있다.

고객 1은 (5, 1), 고객 2는 (5, 4), 고객 3은 (1, 3)에 있다.

고객의 번호는 없애고 싶어하는 몬스터의 번호와 일치한다.



만약, 헌터가 몬스터 1을 없애고 고객 1에게 가고 몬스터 2를 없애고 고객 2에게 가고 몬스터 3을 없애고 고객 3에게 간다고 하자.

이때 걸리는 시간은 [그림-2]와 같이 22시간이다.



 
                                                             [그림-2]



만약, 헌터가 몬스터 3을 없애고 고객 3에게 가고 몬스터 2를 없애고 몬스터 1을 없애고 고객 2에 가고 고객 1에 간다고 하자.

이때 걸리는 시간은 [그림-3]과 같이 18시간이다.





                                                            [그림-3]



[그림-3]의 경우가 주어진 예에서 가장 빨리 모든 작업을 완료할 수 있는 경우이다.



이와 같이 몬스터의 위치와 고객의 위치가 주어졌을 때,

모든 몬스터를 없애고 고객들에게 확인시켜 작업을 완료하는 데 가장 빠른 시간을 구하는 프로그램을 작성해라.



헌터는 처음 (1, 1)부터 시작하고, 몬스터와 고객의 위치가 서로 같은 경우는 없다.

몬스터와 고객의 위치는 (1, 1)로 주어질 수 있다.



[제약 사항]

1. 몬스터의 위치와 고객의 위치는 한 변의 길이 N이 3 이상 10 이하인 정사각형의 맵으로 주어진다. (3≤N≤10)

2. 고객 및 몬스터 개수 M은 1 이상 4 이하이다. (1≤M≤4)

3. 고객 및 몬스터는 1부터 M까지 번호가 부여되어 있다.

4. 고객의 번호는 처리해 달라는 몬스터의 번호이다.

5. 맵에서 몬스터는 양수로 주어지고 고객은 음수로 주어진다.

   그 수의 절대값은 몬스터의 번호 및 고객의 번호를 의미한다. 0인 경우는 아무것도 없는 경우이다.

6. 몬스터와 고객이 같은 위치를 가지는 경우는 없다.

7. 헌터는 상하좌우로 1시간에 한 칸씩 움직일 수 있다.

8. 헌터는 맵의 맨 왼쪽 위인 (1, 1)부터 시작한다.



[입력]

입력은 첫 줄에 총 테스트 케이스의 개수 T가 온다 (1≤T≤50)

그 다음 줄부터 테스트 케이스 T개 온다. 각 테스트 케이스는 모두 N + 1 줄로 구성되어 있다.

첫 줄은 맵의 한 변의 길이 N이 주어진다.

그 다음 N 줄에는 N*N 맵의 정보가 주어진다. 맵에서 양수는 몬스터, 음수는 고객을 뜻한다.



[출력]

테스트 케이스 T에 대한 결과는 “#T”을 찍고, 한 칸 띄고, 정답을 출력한다.

(T는 테스트케이스의 번호를 의미하며 1부터 시작한다.)

정답은 모든 작업을 완료할 수 있는 가장 빠른 시간이다.
"""